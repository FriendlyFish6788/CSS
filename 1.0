#The Code to find Cyclic Sum Sets given the order of n

#Necessary Imports for code
import itertools
import timeit

#The start of a timer for problem number 16


#Getting order for N and number of Terms
N = int(input("enter order of CSS: "))
n = N*N + N + 1
terms = N + 1
potentCSS = set()
permUnsort = []
permUnsortbig = []
permList = []
cssList = []
notUniq = []
potUniq = []
Uniq = []
p = 1

start = timeit.default_timer()

#Code borrowed from Jerome Kelleher to generate partitions efficiently
def accelAsc(n):
    a = [0 for i in range(n + 1)]
    k = 1
    y = n - 1
    while k != 0:
        x = a[k - 1] + 1
        k -= 1
        while 2*x <= y:
            a[k] = x
            y -= x
            k += 1
        l = k + 1
        while x <= y:
            a[k] = x
            a[l] = y
            yield a[:k + 2]
            x += 1
            y -= 1
        a[k] = x + y
        y = x + y - 1
        yield a[:k + 1]
part = accelAsc(n)

def NumDup(n):
    for x in n:
        seen = []
        for i in x:
            if i in seen:
                if x in n:
                    n.remove(x)
                    break
            seen.append(i)
    return n

def filtCopy(n):
    permList = []
    for x in n:
        for y in x:
            if y[0] == 1:
                permList.append(y)
            #else:
                #x.remove(y)
    return permList

def isCSS(L):
    seen = []
    n = len(L)
    for i in range(1,n):
        for start in range(0,n):
            Sum = 0
            for j in range(0,i):
                Sum = Sum + L[(start + j)%n]
            if Sum in seen:
                return False
            seen.append(Sum)
    return True

def UniqCSS(n):
    notUniq = []
    for i in n:
        for j in i:
            if isCSS(j) == True:
                css = []
                css.append(j)
                notUniq.append(css)
    b = len(notUniq)
    potUniq = []
    Uniq = []
    for x in notUniq:
        if x[0][1:b] and x[0][b:0:-1] not in potUniq or not Uniq:
            potUniq.append(x[0][b:0: -1])
            potUniq.append(x[0][1:b])
            Uniq.append(x)
    return Uniq

def trueCSS(n):
    for i in n:
        print("Passed! ", i)

import datetime

def convert(n):
    return str(datetime.timedelta(seconds = n))

#Checking through the partitions to check the CSS properties
#and i not in potentCSS
#create these lists but appending next numbers??

for i in part:
    if (len(i) == terms) and (1 in i) and (2 in i):
        potentCSS.add(tuple(i))


potCSS = list(potentCSS)
#print this
filtered = potCSS[:]
filtPotCSS = NumDup(filtered)

permList2 = []
print(len(filtPotCSS))
y = len(filtPotCSS)
q = 1


#Permutating the Duplicates
def all(filtPotCSS):
    q = 1
    permUnsortbig = []
    permUnsort = []
    permList =[]
    for i in filtPotCSS:
        permUnsortbig.append(list(itertools.permutations(i, len(i))))
        permUnsort = permUnsortbig[:]
        permList = filtCopy(permUnsort)
        permList2.append(permList)
        Left = y - q
        print("Left: ", Left)
        perms = permList2
        trueCSS(UniqCSS(perms))
        filtPotCSS.remove(i)
        q += 1
        permUnsortbig = []
        permUnsort = []
        permList = []

all(filtPotCSS)

#p = 1
#for i in UniqCSS(perms):
 #   print("CSS of order " + str(N) + " number " + str(p), i)
  #  int(p)
   # p += 1
stop = timeit.default_timer()
print(stop - start)
